# -*- coding: utf-8 -*-
"""HAMS Data Science_Carlos_Albarran.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1IMtN8jy-QhqB7qxyAbGA1I3v5vVN_eGy

**#Bayesian Marketing Mix Modeling (MMM)**

I construct a Bayesian Marketing Mix Model (MMM) in this notebook to examine weekly income's effect on advertising expenditure across several channels.


#MMM?

 The statistical method known as marketing mix modeling (MMM) measures the impact of several marketing channels‚ÄîTV, radio, online ads, etc.‚Äîon corporate results including sales or income.

 MMM has long used either linear or log-linear regression models.  Still, these models sometimes miss:

 TV commercials influencing sales over several weeks have **carry-over effects**; uncertainty in parameter estimations; **domain-informed priors**

 Here is where **Bayesian MMM** finds use.



#Why Bayesian?

 With bayesian modeling, we can:

 Add **prior knowledge** (such as ad impact declining over time).
 Model **uncertainty** in parameter estimations
 - Record **temporal dynamics** akin to adstock (delayed effects).
 Even with inadequate or noisy data, **robust inference**



#Goal

 Given weekly revenue and marketing spend across seven channels, we want to:

 1. Using a **adstock transformation**, model the **carry-over effect** of advertising.
 2. Calculate every channel's **contribution**.
 3. Approximate **uncertainty** using posterior distributions
 4. Derive **ROI per channel** optionally at will.

 We implement the model and examine outcomes using **PyMC**.

**Load data in my notebook**
"""

import pandas as pd

# Load the dataset directly from GitHub
url = "https://raw.githubusercontent.com/haensel-ams/recruitment_challenge/master/DataScience_202209/MMM_test_data.csv"
df = pd.read_csv(url, parse_dates=["start_of_week"])

# Preview the dataset
df.head()

"""# Adstock function
Simulating how a campaign ran this week still influences consumer behavior next week, but somewhat less; the adstock function catches how marketing effects decay over time.
"""

import numpy as np

def apply_adstock(series, alpha):
    """
    Apply geometric adstock transformation.
    Args:
        series: array-like (weekly spend)
        alpha: float (adstock decay parameter, between 0 and 1)
    Returns:
        transformed series (np.array)
    """
    result = [series[0]]
    for t in range(1, len(series)):
        result.append(series[t] + alpha * result[t - 1])
    return np.array(result)

"""Appy function to the 7 channels"""

spend_columns = [col for col in df.columns if col.startswith("spend_channel")]
adstock_alpha = 0.5  # Temporary value

adstocked_spend = {}
for col in spend_columns:
    adstocked_spend[col] = apply_adstock(df[col].values, alpha=adstock_alpha)

# Convert to DataFrame for inspection
adstock_df = pd.DataFrame(adstocked_spend)
adstock_df["start_of_week"] = df["start_of_week"]
adstock_df.head()

"""Plot Original vs. Adstocked Spend"""

import matplotlib.pyplot as plt

# Choose example channels
example_channels = ["spend_channel_1", "spend_channel_3"]

# Plot original vs. adstocked for each
plt.figure(figsize=(14, 6))

for i, col in enumerate(example_channels, 1):
    plt.subplot(1, 2, i)
    plt.plot(df["start_of_week"], df[col], label="Original", alpha=0.6)
    plt.plot(df["start_of_week"], adstocked_spend[col], label=f"Adstocked (Œ±={adstock_alpha})", linewidth=2)
    plt.title(col)
    plt.xlabel("Week")
    plt.ylabel("Spend")
    plt.xticks(rotation=45)
    plt.legend()

plt.tight_layout()
plt.show()

"""**Adstocked spend** is more seamless; peaks develop more slowly and dissipate gently.  Thus, the spending of one week affects not only the present week but also the next ones‚Äîjust less and less over time.  This reflects consumer behavior in the actual world, whereby marketing initiatives have **long-lasting effects** over time rather than producing instant purchases solely.

Build PyMC Model (with coords + dims + observe)
"""

import pymc as pm
import arviz as az

# Set up coordinate system
coords = {
    "week": np.arange(len(y)),
    "channel": spend_columns
}

# Build generative model
with pm.Model(coords=coords) as mmm_model:
    # Register data with dimensions
    x = pm.Data("x", X_adstocked, dims=["week", "channel"])
    y_obs = pm.Data("y_obs", y, dims="week")

    # Priors
    intercept = pm.Normal("intercept", mu=0, sigma=1)
    betas = pm.Normal("betas", mu=0, sigma=1, dims="channel")
    sigma = pm.HalfNormal("sigma")

    # Linear model
    mu = intercept + x @ betas

    # Likelihood
    revenue = pm.Normal("revenue", mu=mu, sigma=sigma, observed=y_obs, dims="week")

"""Inference with real data"""

# Run MCMC sampling
with mmm_model:
    trace = pm.sample(1000, tune=1000, target_accept=0.95, random_seed=42, return_inferencedata=True)

"""See results"""

az.summary(trace, var_names=["betas", "intercept", "sigma"])

"""## ** Working MMM using PyMC **

Models adstocked spend per channel

Uses coords and dims for interpretability

Samples posterior distributions for revenue modeling

## ‚Åâ

Seasonality & trend might be interesting to be included in your model

üìà Trend: a linear progression over time

üîÑ Seasonality: recurring weekly patterns using sine/cosine functions
"""

# Step counter
t = np.arange(len(df))

# Weekly seasonality (52 weeks ‚âà 1 cycle)
df["sin_week"] = np.sin(2 * np.pi * t / 52)
df["cos_week"] = np.cos(2 * np.pi * t / 52)
df["trend"] = t

# Add these to your features
X_trend_season = np.column_stack([X_adstocked, df["trend"], df["sin_week"], df["cos_week"]])

"""Update channels:"""

extended_features = spend_columns + ["trend", "sin_week", "cos_week"]

"""Update the model"""

coords = {
    "week": np.arange(len(df)),
    "channel": extended_features
}

with pm.Model(coords=coords) as mmm_extended_model:
    x = pm.Data("x", X_trend_season, dims=["week", "channel"])
    y_obs = pm.Data("y_obs", y, dims="week")

    # Priors
    intercept = pm.Normal("intercept", mu=0, sigma=1)
    betas = pm.Normal("betas", mu=0, sigma=1, dims="channel")
    sigma = pm.HalfNormal("sigma")

    # Linear regression with trend and seasonality
    mu = intercept + x @ betas

    revenue = pm.Normal("revenue", mu=mu, sigma=sigma, observed=y_obs, dims="week")

    trace_extended = pm.sample(1000, tune=1000, target_accept=0.95, random_seed=42, return_inferencedata=True)

# View updated model summary
az.summary(trace_extended, var_names=["betas", "intercept", "sigma"])

az.plot_forest(trace_extended, var_names=["betas"], combined=True)

"""üîª Trend:
The model learned that revenue is going down over time, regardless of how much is spent on marketing.

üîÅ Seasonality:

I added seasonal patterns using sine and cosine waves (like waves in time) ‚Äî and the model picked up on some recurring weekly or yearly patterns in the data.
That means:

There are weeks when revenue tends to go up or down in a repeating way,


üìä Marketing Channels
When we look at the channel effects (betas):

Some channels like Channel 1 and Channel 2 show a strong negative effect, meaning more spend = lower revenue, which doesn't make intuitive sense.

Most channels have coefficients centered near or below zero ‚Äî suggesting they aren‚Äôt contributing positively, at least not in the way the model sees it.

This could mean:
The ad spend isn‚Äôt well aligned with performance,
The fixed adstock (alpha = 0.5) isn‚Äôt flexible enough ‚Äî we might want to learn it from data next.

### Bonus: ROI per Channel

![Capture22222.PNG](data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAX0AAABJCAYAAADR5fZeAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsMAAA7DAcdvqGQAABufSURBVHhe7Z2HrxXF+8Z//4CKJRqIGiGCEaIYWxBBUYM1okaNgA0N9hrEEmyxIopKVOyCRiWKBjUWiL0hGmwoolgiduwKtqhxv7/PeJ7re+fOnj3ncu5hued9ks29Z3d2+jzzzvu+M/t/mcPhcDhaBk76DofD0UJw0nc4HI4WgpO+w+FwtBCc9B0Oh6OF4KTvcDgcLQQnfYfD4WghOOk7HA5HC8FJ3+FwOFoITvoOh8PRQnDSdzgcjhaCk77D4XC0EJz0HQ6Ho4XgpO9wOBwtBCd9R7fGn3/+mV1++eXZm2++WbnjcKwc/PTTT9n48eOzzz//vHJn5cBJv2T4559/shdffDHbd999s0033TQ78cQTu7STvPfee9kDDzzQdj399NPZb7/9Vnmaxq+//prNmTOn3XvEUzZA+Kecckp29dVXh3qthkcffTTU95IlSyp3ascPP/yQPfLII9m9996bnXvuudknn3xSeVI+NCuvf/31V/b888+HvnHJJZdkjz/+eOVJdfz999/Zgw8+mO20006hPcaMGZPNnz8/W7ZsWXbllVeGvld2kF/KTb+74447Knf/xauvvpoNHz48+/TTTyt3mg8n/RIBkpo4cWI2bty47Pvvvw8D4MYbb8y222677JtvvqmEaiwYjMcff3wYYKuttlq2+uqrZ0888UTlaRo333xzCEf4bbfdNjvppJNqHtTNxK233poddNBBhZMYE8Kxxx4bynPfffdV7tYOiPPoo4/O1lprrWzdddfN3njjjcqT8qFZef3999+zyZMnt/Wrq666qvIkH/R/+tIuu+ySvfXWW2GCmjt3brbzzjuHfrbnnntmv/zySyV0eQHRk1/KTV3HqLVfdhWc9EsEpK8pU6a0k0oZlD179uxyUn3sscfC6mLttdfOjjjiiCCppUBHPf3007O99tordGreKyM++uijbMsttwykUYQvvvgi69+/fyhPtbIXgQHeWSLlndNOO63yq+uxInmtB/SPWkkfMtxkk01C21n8/PPP2W677ZbtscceqwTpA+qV+k2RPgIdK5l77rmncqe5cNIvCVArHHLIIaFDWLz22muh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)
"""

# Extract posterior beta samples
beta_samples = trace.posterior["betas"].stack(samples=("chain", "draw")).values

# Make sure we only use the first 7 coefficients (i.e., channels, excluding trend/sin/cos)
beta_samples_channels = beta_samples[:, :len(spend_columns)]

# Mean adstocked spend per channel
mean_adstocked = X_adstocked.mean(axis=0)

# Mean raw spend per channel
mean_raw_spend = df[spend_columns].mean().values

# ROI samples: (beta_i * adstocked_mean_i) / raw_mean_i
roi_samples = (beta_samples_channels.T * mean_adstocked[:, None]) / mean_raw_spend[:, None]

# ROI summary: mean and 95% interval
import arviz as az
roi_mean = roi_samples.mean(axis=1)
roi_hdi = az.hdi(roi_samples.T, hdi_prob=0.95)

# Put it in a DataFrame
import pandas as pd
roi_df = pd.DataFrame({
    "Channel": spend_columns,
    "ROI Mean": roi_mean,
    "ROI 2.5%": roi_hdi[:, 0],
    "ROI 97.5%": roi_hdi[:, 1],
})

# Sort channels by ROI
roi_df = roi_df.sort_values(by="ROI Mean", ascending=False)
roi_df.reset_index(drop=True, inplace=True)

# Display table
print(roi_df)

import matplotlib.pyplot as plt

plt.figure(figsize=(10, 6))
plt.errorbar(roi_df["Channel"], roi_df["ROI Mean"],
             yerr=[roi_df["ROI Mean"] - roi_df["ROI 2.5%"],
                   roi_df["ROI 97.5%"] - roi_df["ROI Mean"]],
             fmt='o', capsize=5)
plt.title("Estimated ROI per Channel (with 95% HDI)")
plt.xticks(rotation=45)
plt.ylabel("ROI (Revenue / Spend)")
plt.grid(True)
plt.tight_layout()
plt.show()

"""None of the seven channels offer a clearly positive return on investment based on the projected ROI, hence all have great uncertainty... again!!

"""

